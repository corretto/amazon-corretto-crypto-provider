#include "openssl/base.h"
#include "buffer.h"
#include "env.h"
#include "generated-headers.h"
#include "util.h"


// Transform DIGEST_NAME from "sha3_224" format to "SHA3224" format for JNI class names
// This macro needs to be defined for each digest algorithm
#define TRANSFORM_sha3_224 SHA3224
#define TRANSFORM_sha3_256 SHA3256
#define TRANSFORM_sha3_384 SHA3384
#define TRANSFORM_sha3_512 SHA3512

#define GET_TRANSFORMED_NAME(digest) CONCAT2(TRANSFORM_, digest)

#define JNI_NAME(name) CONCAT2( \
        CONCAT2(Java_com_amazon_corretto_crypto_provider_, GET_TRANSFORMED_NAME(DIGEST_NAME)), \
        CONCAT2(Spi_, name) \
    )

#define MD CONCAT2(EVP_, DIGEST_NAME)
#define CTX EVP_MD_CTX

using namespace AmazonCorrettoCryptoProvider;



JNIEXPORT jint JNICALL JNI_NAME(getContextSize)(JNIEnv*, jclass) { return MD_CTX_SIZE; }

JNIEXPORT jint JNICALL JNI_NAME(getHashSize)(JNIEnv*, jclass) { return DIGEST_LENGTH; }

JNIEXPORT void JNICALL JNI_NAME(initContext)(JNIEnv* pEnv, jclass, jbyteArray contextArray)
{
    try {
        raii_env env(pEnv);
        
        //We are unable to use bounce buffers like hash_template.cpp.template does because of the way EVP_MD_CTX is set up
        CTX ctx;
        
        CHECK_OPENSSL(EVP_DigestInit(&ctx, MD()));

        java_buffer contextBuffer = java_buffer::from_array(env, contextArray);

        if (unlikely(contextBuffer.len() != MD_CTX_SIZE)) {
            throw_java_ex(EX_ILLEGAL_ARGUMENT, "Bad context buffer size");
        }

        contextBuffer.put_bytes(env, reinterpret_cast<const uint8_t*>(ctx.md_data), 0, MD_CTX_SIZE);

    } catch (java_ex& ex) {
        ex.throw_to_java(pEnv);
    }
}


JNIEXPORT void JNICALL JNI_NAME(updateContextByteArray)(
    JNIEnv* pEnv, jclass, jbyteArray contextArray, jbyteArray dataArray, jint offset, jint length)
{
    try {
        raii_env env(pEnv);

        //We are unable to use bounce buffers like hash_template.cpp.template does because of the way EVP_MD_CTX is set up
        CTX ctx;
        
        java_buffer contextBuffer = java_buffer::from_array(env, contextArray);

        {
            CHECK_OPENSSL(EVP_DigestInit(&ctx, MD()));

            jni_borrow contextBorrow(env, contextBuffer, "contextBuffer");

            //Setting the state of the ctx pointer to the context passed in through the function call
            memcpy(ctx.md_data, contextBorrow.data(), MD_CTX_SIZE);
        }

        {
            java_buffer databuf = java_buffer::from_array(env, dataArray, offset, length);
            jni_borrow dataBorrow(env, databuf, "databuf");
            
            CHECK_OPENSSL(EVP_DigestUpdate(&ctx, dataBorrow.data(), dataBorrow.len()));

        }
        contextBuffer.put_bytes(env, reinterpret_cast<const uint8_t*>(ctx.md_data), 0, MD_CTX_SIZE);

    } catch (java_ex& ex) {
        ex.throw_to_java(pEnv);
    }
}




JNIEXPORT void JNICALL JNI_NAME(finish)(
    JNIEnv* pEnv, jclass, jbyteArray contextArray, jbyteArray digestArray, jint offset)
{
    try {
        raii_env env(pEnv);
        
        //We are unable to use bounce buffers like hash_template.cpp.template does because of the way EVP_MD_CTX is set up
        CTX ctx;

        java_buffer contextBuffer = java_buffer::from_array(env, contextArray);
        {            
            CHECK_OPENSSL(EVP_DigestInit(&ctx, MD()));

            jni_borrow contextBorrow(env, contextBuffer, "contextBuffer");

            memcpy(ctx.md_data, contextBorrow.data(), MD_CTX_SIZE);
        }
        
        int success;
        {
            java_buffer digestbuf = java_buffer::from_array(env, digestArray);
            jni_borrow digestBorrow(env, digestbuf, "digestbuf");

            unsigned out_size;
            success = EVP_DigestFinal(&ctx, digestBorrow.check_range(offset, DIGEST_LENGTH), &out_size);

            if (unlikely(!success)) {
                digestBorrow.zeroize();
            }
        }

        uint8_t zeros[MD_CTX_SIZE] = {0};
        contextBuffer.put_bytes(env, zeros, 0, MD_CTX_SIZE);
        
        if (unlikely(!success)) {
            throw_openssl();
        }
    } catch (java_ex& ex) {
        ex.throw_to_java(pEnv);
    }
}




JNIEXPORT void JNICALL JNI_NAME(updateNativeByteBuffer)(
    JNIEnv* pEnv, jclass, jbyteArray contextArray, jobject dataDirectBuf)
{
    try {
        raii_env env(pEnv);
        
        //We are unable to use bounce buffers like hash_template.cpp.template does because of the way EVP_MD_CTX is set up
        CTX ctx;

        java_buffer contextBuffer = java_buffer::from_array(env, contextArray);

        {
            jni_borrow contextBorrow(env, contextBuffer, "contextBuffer");
            CHECK_OPENSSL(EVP_DigestInit(&ctx, MD()));
            memcpy(ctx.md_data, contextBorrow.data(), MD_CTX_SIZE);
        }

        {
            java_buffer dataBuf = java_buffer::from_direct(env, dataDirectBuf);
            jni_borrow dataBorrow(env, dataBuf, "dataBorrow");
            CHECK_OPENSSL(EVP_DigestUpdate(&ctx, dataBorrow.data(), dataBorrow.len()));
        }
        contextBuffer.put_bytes(env, reinterpret_cast<const uint8_t*>(ctx.md_data), 0, MD_CTX_SIZE);

    } catch (java_ex& ex) {
        ex.throw_to_java(pEnv);
    }
}



JNIEXPORT void JNICALL JNI_NAME(fastDigest)(
    JNIEnv* pEnv, jclass, jbyteArray digestArray, jbyteArray dataArray, jint bufOffset, jint dataLength)
{
    // As this method needs to be extremely high speed, we are omitting use of java_buffer
    // to avoid the extra JNI calls it requires. Instead we are trusting that dataLength
    // is correct.
    try {
        raii_env env(pEnv);
        
        SecureBuffer<CTX,1> ctx;
        const size_t scratchSize = DIGEST_BLOCK_SIZE; // Size is arbitrarily chosen
        SecureBuffer<uint8_t, DIGEST_LENGTH> digest;

        if (unlikely(!EVP_DigestInit(ctx, MD()))) {
            throw java_ex::from_openssl(EX_RUNTIME_CRYPTO, "Unable to initialize context");
        }

        if (static_cast<size_t>(dataLength) > scratchSize) {
            java_buffer dataBuffer = java_buffer::from_array(env, dataArray, bufOffset, dataLength);
            jni_borrow dataBorrow(env, dataBuffer, "data");
            if (unlikely(!EVP_DigestUpdate(ctx, dataBorrow.data(), dataBorrow.len()))) {
                throw java_ex::from_openssl(EX_RUNTIME_CRYPTO, "Unable to update context");
            }
        } else {
            SecureBuffer<uint8_t, scratchSize> scratch;
            env->GetByteArrayRegion(dataArray, bufOffset, dataLength, reinterpret_cast<jbyte*>(scratch.buf));
            if (unlikely(!EVP_DigestUpdate(ctx, scratch, dataLength))) {
                throw java_ex::from_openssl(EX_RUNTIME_CRYPTO, "Unable to update context");
            }
        }
        unsigned int out_size;
        if (unlikely(!EVP_DigestFinal(ctx, digest, &out_size))) {
            throw java_ex::from_openssl(EX_RUNTIME_CRYPTO, "Unable to finish digest");
        }
        env->SetByteArrayRegion(digestArray, 0, DIGEST_LENGTH, reinterpret_cast<const jbyte*>(digest.buf));

    } catch (java_ex& ex) {
        ex.throw_to_java(pEnv);
    }

    
}
